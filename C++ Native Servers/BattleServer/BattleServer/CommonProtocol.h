//#ifndef __GODDAMNBUG_ONLINE_PROTOCOL__
//#define __GODDAMNBUG_ONLINE_PROTOCOL__

/*
-------------------------------------------------
2018.02.12

	추가 en_PACKET_CS_GAME_REQ_HIT_DAMAGE
	추가 en_PACKET_CS_GAME_RES_HIT_DAMAGE

	추가 en_PACKET_CS_GAME_REQ_FIRE1
	추가 en_PACKET_CS_GAME_RES_FIRE1

	추가 en_PACKET_CS_GAME_RES_LEAVE_USER

	추가 en_PACKET_CS_GAME_REQ_HIT_POINT
	추가 en_PACKET_CS_GAME_RES_HIT_POINT

	추가 en_PACKET_CS_GAME_REQ_RELOAD
	추가 en_PACKET_CS_GAME_RES_RELOAD






2018.02.10

	변경 en_PACKET_CS_GAME_REQ_MOVE_PLAYER

		삭제 INT64	AccountNo

		원래 없었는데 제가 실수로 적혀있었습니다.
		이동 요청 REQ 에는 AccountNo 가 없으며,  RES 에는 있습니다.



2018.02.08

	배틀서버는 릴레이서버 역할로서 대부분의 컨텐츠를 클라이언트가 직접 처리하게 됩니다.
	서버는 클라이언트의 정보를 보관 후 다른 클라에게 뿌려주면 됩니다.

	아직 이동에대한 동기화를 완벽하게 마무리하지 못한 상태로서 상황에 따라서 프로토콜이 많이 변경될 수 있습니다.
	(시도하던 방식이 도저히 안되서 다른 방향으로 해결중)
	

	추가	 en_PACKET_CS_GAME_RES_CREATE_MY_CHARACTER
	추가	 en_PACKET_CS_GAME_RES_CREATE_OTHER_CHARACTER

	추가	 en_PACKET_CS_GAME_REQ_MOVE_PLAYER,
	추가	 en_PACKET_CS_GAME_RES_MOVE_PLAYER,



	추가 en_PACKET_CS_GAME_RES_ADD_USER,
	추가 en_PACKET_CS_GAME_RES_REMOVE_USER,

	변경 en_PACKET_CS_MATCH_REQ_LOGIN,
	
		추가		UINT	Ver_Code

		매칭서버의 설정파일을 통해서 버전코드를 입력받도록 해야 함


	변경 en_PACKET_CS_MATCH_RES_LOGIN,

		상태값 추가  5 : 버전오류


	변경 en_PACKET_CS_GAME_REQ_LOGIN,

		추가		UINT	Ver_Code

		배틀서버의 설정파일을 통해서 버전코드를 입력받도록 해야 함


	변경 en_PACKET_CS_GAME_RES_LOGIN,

		상태값 추가  5 : 버전오류







-------------------------------------------------
2018.01.13

	# 추가 : en_PACKET_CHAT_BAT_REQ_DESTROY_ROOM		배틀 -> 채팅
	# 추가 : en_PACKET_CHAT_BAT_RES_DESTROY_ROOM		채팅 -> 배틀

	배틀서버에서 방이 파괴 되었음을 채팅 서버에게 알림
	채팅서버는 해당 메시지 수신시 방을 파괴 함.

	없어도 큰 문제 없을줄 알았으나 필요하게 되어 추가 함.

-------------------------------------------------
2018.01.04

	# 추가 : en_PACKET_CS_GAME_REQ_LOGIN
	# 추가 : en_PACKET_CS_GAME_RES_LOGIN
	# 추가 : en_PACKET_CS_GAME_REQ_ENTER_ROOM
	# 추가 : en_PACKET_CS_GAME_RES_ENTER_ROOM
	# 추가 : en_PACKET_CS_GAME_RES_PLAY_READY
	# 추가 : en_PACKET_CS_GAME_RES_PLAY_START

	클라이언트와 배틀서버간의 방 입장 관련 프로토콜 추가





-------------------------------------------------
2017.12.19

	# 변경 : en_PACKET_CS_CHAT_REQ_LOGIN

		삭제		char	SessionKey[64];
		추가		char	ConnectToken[32];

		채팅서버가 기존 로그인서버 연결 방식에서 배틀서버 연결로 변경 되면서
		사용자의 세션키 인증이 아닌 연결 자체만 확인하는 ConnectToken 방식으로 변경

		채팅서버는 배틀서버로부터 받은 ConnectToken 을 들고 있으며, 사용자의 접속시 비교한다.


	-------------------------------------------------

	# 삭제 : en_PACKET_CS_CHAT_REQ_SECTOR_MOVE
	# 삭제 : en_PACKET_CS_CHAT_RES_SECTOR_MOVE

	# 신규 : en_PACKET_CS_CHAT_REQ_ENTER_ROOM
	# 신규 : en_PACKET_CS_CHAT_RES_ENTER_ROOM

		X, Y 섹터 이동 개념이 아닌 방 개념으로 변경되었으므로
		SECTOR_MOVE 패킷을 없애고, ENTER_ROOM 으로 변경.

		채팅서버에서는 각 방에 대한 RoomNo / EnterToken 을 관리.

		섹터 단위가 아닌 방 단위로 방 내의 사람들 끼리만 채팅
	
	-------------------------------------------------


	# 변경 : en_PACKET_CS_MATCH_RES_GAME_ROOM

		추가 WCHAR	ChatServerIP[16]	채팅서버 접속 IP
		추가 WORD	ChatServerPort		채팅서버 접속 Port

		배틀서버/채팅서버  세트 단위로 구성 됨.

		게임서버 접속정보 전달시 채팅서버의 IP / Port 를 함께 전달 한다.
		ConnectToken 과 EnterToken 은 배틀서버와 같은 것으로 사용한다.

		채팅서버의 IP / Port 는 배틀서버가 가지고 있음 (채팅서버가 배틀서버에 연결시 전달)

	-------------------------------------------------

	# 변경 : en_PACKET_MAT_MAS_RES_GAME_ROOM
	
		추가 WCHAR	ChatServerIP[16]	채팅서버 접속 IP
		추가 WORD	ChatServerPort		채팅서버 접속 Port

		마스터 서버가 매칭서버에게 바 결과를 줄 때도 채팅서버 정보를 추가 한다.

	-------------------------------------------------

	# 변경 : en_PACKET_BAT_MAS_REQ_SERVER_ON
	
		추가 WCHAR	ChatServerIP[16]	채팅서버 접속 IP
		추가 WORD	ChatServerPort		채팅서버 접속 Port

		배틀서버 가동시 채팅서버 IP/Port 도 함께 전달

	-------------------------------------------------

	# 추가 : en_PACKET_CHAT_BAT_REQ_SERVER_ON
	# 추가 : en_PACKET_CHAT_BAT_REQ_SERVER_ON
	# 추가 : en_PACKET_CHAT_BAT_RES_SERVER_ON
	# 추가 : en_PACKET_CHAT_BAT_REQ_CONNECT_TOKEN
	# 추가 : en_PACKET_CHAT_BAT_RES_CONNECT_TOKEN
	# 추가 : en_PACKET_CHAT_BAT_REQ_CREATED_ROOM
	# 추가 : en_PACKET_CHAT_BAT_RES_CREATED_ROOM

		채팅서버와 배틀서버간의 통신용 프로토콜 추가.


*/




enum en_PACKET_TYPE
{
	////////////////////////////////////////////////////////
	//
	//	Client & Server Protocol
	//
	////////////////////////////////////////////////////////


	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Chatting Server
	//------------------------------------------------------
	en_PACKET_CS_CHAT_SERVER			= 0,

	//------------------------------------------------------------
	// 채팅서버 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WCHAR	ID[20]				// null 포함
	//		WCHAR	Nickname[20]		// null 포함
	//		char	ConnectToken[32];
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_REQ_LOGIN,

	//------------------------------------------------------------
	// 채팅서버 로그인 응답
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status				// 0:실패	1:성공
	//		INT64	AccountNo
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_RES_LOGIN,

	//------------------------------------------------------------
	// 채팅서버 방 입장
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//		char	EnterToken[32]
	//	}
	//
	//------------------------------------------------------------
	// en_PACKET_CS_CHAT_REQ_SECTOR_MOVE	기존 패킷 삭제
	en_PACKET_CS_CHAT_REQ_ENTER_ROOM,

	//------------------------------------------------------------
	// 채팅서버 방 입장 결과
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//		BYTE	Status					1: 성공
	//										2: Token 오류
	//										3: 없는 방
	//	}
	//
	//------------------------------------------------------------
	// en_PACKET_CS_CHAT_RES_SECTOR_MOVE	기존 패킷 삭제
	en_PACKET_CS_CHAT_RES_ENTER_ROOM,

	//------------------------------------------------------------
	// 채팅서버 채팅보내기 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WORD	MessageLen
	//		WCHAR	Message[MessageLen / 2]		// null 미포함
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_REQ_MESSAGE,

	//------------------------------------------------------------
	// 채팅서버 채팅보내기 응답  (다른 클라가 보낸 채팅도 이걸로 받음)
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WCHAR	ID[20]						// null 포함
	//		WCHAR	Nickname[20]				// null 포함
	//		
	//		WORD	MessageLen
	//		WCHAR	Message[MessageLen / 2]		// null 미포함
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_CHAT_RES_MESSAGE,

	//------------------------------------------------------------
	// 하트비트
	//
	//	{
	//		WORD		Type
	//	}
	//
	//
	// 클라이언트는 이를 30초마다 보내줌.
	// 서버는 40초 이상동안 메시지 수신이 없는 클라이언트를 강제로 끊어줘야 함.
	//------------------------------------------------------------	
	en_PACKET_CS_CHAT_REQ_HEARTBEAT,









	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Login Server
	//------------------------------------------------------
	en_PACKET_CS_LOGIN_SERVER				= 100,


	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Battle Server
	//------------------------------------------------------
	en_PACKET_CS_GAME_SERVER				= 1000,


	//------------------------------------------------------------
	// 배틀서버로 클라이언트 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		char	SessionKey[64]
	//
	//		char	ConnectToken[32]
	//		UINT	Ver_Code
	//	}
	//
	//	배틀서버로 로그인 시 사용자의 SessionKey 확인과 ConnectToken 을 확인 한다.
	//	SessionKey 를 배틀서버가 shDB 를 통해 확인하는 과정이 부담스러울 수 있으나 사용자 인증이 필요하므로 어쩔 수 업음
	//
	//	SessionKey 를 매칭서버 -> 마스터서버 -> 배틀서버 경로로 전달하여  배틀서버가 shDB 조회하는 부분을 줄일 수 는 있겠으나
	//	이것 또한 더 부담되며, 배틀서버는 어차피 닉네임 등 계정정보 확인을 위해서 shDB 를 조회 해아 함.
	//
	//	배틀서버는 로그인요청 수신시 shDB 를통해 세션키 확인 / 계정정보 획득 / ConnectToken 확인 (AUTH 스레드)
	//	유저가 방 입장 후 게임플레이 전환 전 까지는 계속 AUTH 스레드에 머물도록 한다.
	//
	//  배틀서버 버전코드 들어감.  단순 숫자가 아니며 고유한 코드값.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_LOGIN,

	//------------------------------------------------------------
	// 로그인 응답
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		BYTE	Result			//	1 : 성공 
	//									2 : 사용자 오류
	//									3 : 세션키 오류
	//									5 : 버전오류
	//	}
	//
	//	응답의 AccountNo 는 별 필요는 없으나 정확한 테스트를 위해서 넣음.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_LOGIN,



	//------------------------------------------------------------
	// 배틀서버의 방에 입장 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//
	//		char	EnterToken[32]
	//	}
	//
	//	배틀서버의 특정 방에 입장을 요청한다.
	//	사용자의 AccountNo 는 버그 감지 및 테스트를 위해서 넣은 데이터 임.
	//
	//	배틀서버에서는 어떤 방에 어떤 유저가 들어올지는 알지 못하는 상태이므로
	//	EnterToken 만 일치 한다면 입장을 허용 한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_ENTER_ROOM,

	//------------------------------------------------------------
	// 방 입장 응답
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		int		RoomNo
	//
	//		BYTE	Result				//	1 : 성공
	//									//	2 : EnterToken 불일치
	//									//	3 : 대기방 아님
	//									//	4 : 방 없음
	//									//	5 : 방 가득 참
	//	}
	//
	//	AccountNo 와 RoomNo 는 테스트 및 버그 확인을 위해 넣은 응답 데이터이며, 실제로는 없어도 됨.
	//	(더미에서 잘못된 패킷 수신을 확인하기 위해 있는 용도)
	//
	//	사용자가 방 입장에 성공을 했더라도 이 유저는 AUTH 모드를 유지한다.
	//	실제로 플레이 상태가 되어야만 해당 방과 사용자들을 GAME 모드로 전환 한다.
	//
	//	# 사용자가 방을 나간다는 패킷은 별도로 없음.
	//	# 대기 방에서 접속을 종료하면 그냥 나가는 것으로 처리 함.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_ENTER_ROOM,






	//------------------------------------------------------------
	// 배틀서버 대기방 플레이 준비.
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		BYTE	ReadySec		// 플레이 준비 시간, 초		기본 10초
	//	}
	//
	//	특정 방이 플레이를 위한 준비 카운트 다운 돌입.
	//	해당 방의 모든 유저에게 전달 한다.
	//
	//	배틀서버는 방의 인원이 모두 모이면 [대기방] 을 플레이를 위한 [준비방] 으로 전환 한다.
	//	역시나 아직 AUTH 모드 상태이다.
	//
	//	준비방이 되면 Closed 상태가 되며, 추가적인 입장은 불가능 하다.
	//	이때 나간 유저는 그냥 나가는 것이며 인원이 적어졌더라도 플레이는 진행 한다.
	//	모든 유저가 나가버렸다면 방은 파괴 된다.
	//
	//	WaitSec 시간이 되면 플레이 상태로 전환 한다. (이 때 다시 클라에게 패킷 송신)
	//
	//	서버가 클라에게 통보만 하고 응답은 받지 않음.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_PLAY_READY,


	//------------------------------------------------------------
	// 배틀서버 대기방 플레이 시작
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//	}
	//
	//	게임 시작,
	//	해당 방의 모든 유저에게 전달 한다.
	//	
	//	플레이 상태 (GAME 모드) 로 전환.
	//
	//
	//	본 게임은 대기방시 인원 목록만 나오며 카운트 다운 후 게임씬으로 전환 된다.
	//	만약 배틀그라운드 처럼 대기중인 상태에서도 플레이가 되는 게임이라면 대기모드 상태 역시 하나의 게임으로 보아야 함
	//
	//	이후는 실제 게임 진행 컨텐츠로 ... ~
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_PLAY_START,



	//------------------------------------------------------------
	// 배틀서버 방에 유저가 추가 됨.
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	AccountNo
	//		WCHAR	Nickname[20]
	//	}
	//
	//	대기중인 방에 유저가 추가됨을 알림 /
	//	
	//	- 내가 대기방에 입장 할 때 기존에 있던 유저들의 정보 (여러명이 있는 경우 개별패킷으로 전달)
	//	- 대기방에 들어가 있는데 다른 유저가 들어왔다는 정보
	//  - 자기 자신의 입장도 자신에게 본 패킷을 보내준다. (클라이언트 로직의 간결화를 위해 자신에게도 보내는걸로 함)
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_ADD_USER,

	//------------------------------------------------------------
	// 배틀서버 방에서 유저가 나감 (AUTH 전용)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	AccountNo
	//	}
	//
	//	대기중인 방에서 유저가 나감을 알림
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_REMOVE_USER,



	//-----------------------------------------------------------
	//-----------------------------------------------------------
	// 여기부터는 GAME_MODE 스레드 처리 패킷
	//-----------------------------------------------------------
	//-----------------------------------------------------------

	//------------------------------------------------------------
	// 내 캐릭터 생성
	//
	//	{
	//		WORD	Type
	//		
	//		float	PosX
	//		float	PosY
	//		int		HP
	//	}
	//
	//  GAME 모드로 전환시 캐릭터 게임 컨텐츠를 셋팅하면서 보냄
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_CREATE_MY_CHARACTER,

	//------------------------------------------------------------
	// 다른유저 캐릭터 생성
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		WCHAR	Nickname[20]
	//
	//		float	PosX
	//		float	PosY
	//		int		HP
	//	}
	//
	//  GAME 모드로 전환시 캐릭터 게임 컨텐츠를 셋팅하면서 보냄
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_CREATE_OTHER_CHARACTER,



	//------------------------------------------------------------
	// 캐릭터 이동
	//
	//	{
	//		WORD	Type
	//
	//		float	MoveTargetX
	//		float	MoveTargetY
	//		float	MoveTargetZ
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//
	//	MoveTarget 캐릭터가 이동할 목적지
	//	HitPoint 캐릭터가 바라보는 위치 (시야 및 총발사 타겟)
	//	
	//	서버는 이 정보를 그대로 저장하며, 그대로 다른 유저에게 뿌려준다.
	//	서버에서는 별도로 이동이 없으며 클라이언트의 정보를 저장과 릴레이하는 역할만 함.
	//
	//	별도의 정지는 없으며 다른 유저의 화면에서 내 캐릭터는 같은 목적지까지 이동만을 하면 된다.
	//
	//	실제 클라이언트에서 Y 축은 사용되지 않으며, Z 축이 맵에서의 Y 와 같은 역할을 함. Y 는 높이개념
	//	이는 서버가 구분할 필요는 없으며 참고로 알아두면 됨.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_MOVE_PLAYER,

	//------------------------------------------------------------
	// 캐릭터 이동 (자신에게는 보내지 않음)
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//
	//		float	MoveTargetX
	//		float	MoveTargetY
	//		float	MoveTargetZ
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	위에서 받은 패킷을 그대로 다른 유저에게 전달한다.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_MOVE_PLAYER,

	//------------------------------------------------------------
	// 캐릭터 HitPoint (자신에게는 보내지 않음)
	//
	//	{
	//		WORD	Type
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	캐릭터가 바라보는 시점으로 일정시간마다 반복적으로 보냄
	//	서버는 이를 다른 유저에게 보내준다.
	//
	//	실시간으로 보낼 필요는 없으나 시야 동기화를 위해서 보냄
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_HIT_POINT,

	//------------------------------------------------------------
	// 캐릭터 HitPoint 
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_HIT_POINT,




	//------------------------------------------------------------
	// Fire1 발사 (총 발사)
	//
	//	{
	//		WORD	Type
	//
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	총 발사. 발사 Target 지점을 보냄.
	//
	//	서버는 다른 유저에게 RES 패킷을 뿌림
	//	총에 맞은 오브젝트는 별도의 패킷으로 전송
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_FIRE1,


	//------------------------------------------------------------
	// Fire1 발사 (총 발사)
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		float	HitPointX
	//		float	HitPointY
	//		float	HitPointZ
	//	}
	//
	//	총 발사. 발사 Target 을 보냄.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_FIRE1,





	//------------------------------------------------------------
	// Reload Request
	//
	//	{
	//		WORD	Type
	//	}
	//
	//
	//	총알 재장전. 
	//
	//	서버는 본 패킷을 다른 유저에게 뿌림
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_RELOAD,

	//------------------------------------------------------------
	// Reload Response
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_RELOAD,



	
	//------------------------------------------------------------
	// HitDamage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	TargetAccountNo		// 피해자 AccountNo
	//	}
	//
	//	공격자의 타격 패킷.
	//
	//	공격자가 클라이언트에서 총 발사 후 타격 판정시 공격자 클라이언트에서 피격 처리 후
	//	서버에 본 패킷을 전송 함.  해당 클라이언트에서 HP 는 셀프로 차감 됨.
	//
	//	서버에서는 데미지 처리 HP 차감 후 해당 클라이언트를 제외 한 다른 유저에게 보냄
	//	피격은 클라이언트가 결정 하지만 HP 차감 계산은 서버가 전담 함.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_REQ_HIT_DAMAGE,


	//------------------------------------------------------------
	// HitDamage
	//
	//	{
	//		WORD	Type
	//
	//		INT64	TargetAccountNo		
	//		int		TargetHP			// 피해자의 현재 Total HP
	//	}
	//
	//	피격 결과  패킷.
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_HIT_DAMAGE,









	//------------------------------------------------------------
	// 배틀서버 방에서 유저가 나감 (GAME 전용)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		INT64	AccountNo
	//	}
	// 플레이중인 방에서 유저가 나감을 알림
	//------------------------------------------------------------
	en_PACKET_CS_GAME_RES_LEAVE_USER,





	//------------------------------------------------------------
	// 하트비트
	//
	//	{
	//		WORD		Type
	//	}
	//
	// 클라이언트는 이를 20초마다 보내줌. 서버는 30초 이상동안 통신이 없는 클라이언트를 강제로 끊어줘야 함.
	//------------------------------------------------------------	
	en_PACKET_CS_GAME_REQ_HEARTBEAT,











	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Matchmaking Server
	//------------------------------------------------------
	en_PACKET_CS_MATCH_SERVER				= 2000,

	//------------------------------------------------------------
	// 매치메이킹 서버로 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		INT64	AccountNo
	//		char	SessionKey[64];
	//	
	//		UINT	Ver_Code
	//	}
	//
	//	매치메이킹 서버는 클라이언트 접속시 SessionKey 를 shDB 에서 확인하여 로그인 인증 함.
	//	접속 후 클라이언트 고유 키 (Client Key) 를 생성하여 관리한다. (전 매치메이킹 서버 대상의 유니크 값 이어야 함)
	//
	//	Client Key 의 용도는 마스터 서버에서 클라이언트를 구분하는 값으로 
	//	매치메이킹 서버가 마스터 서버에게 방 생성 요청, 입장확인 시 사용 함.
	//
	//  AccountNo 는 새로운 접속시 중복되므로 사용 할 수 없음.
	//
	//  매치메이킹 서버코드 들어감. 버전 코드는 단순 숫자가 아니며 고유 값으로 부여됨.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_REQ_LOGIN,


	//------------------------------------------------------------
	// 매치메이킹 서버에서 로그인 결과  
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status			1 : 성공
	//								2 : 세션키 오류
	//								3 : AccountNo 없음
	//								4 : 기타 오류
	//								5 : 버전오류
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_RES_LOGIN,


	//------------------------------------------------------------
	// 방 정보 요청
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	클라이언트가 매치메이킹 서버에게 방 정보를 요청 함.
	//
	//	매치메이킹 서버는 마스터 서버에게 ClientKey 와 방정보 요청을 보낸 뒤
	//	마스터 서버에게서 받은 정보를 클라이언트에게 돌려주면 된다.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_REQ_GAME_ROOM,
	
	//------------------------------------------------------------
	// 방 정보 결과
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	Status				1 : 방 정보 얻기 성공 (아래 정보 있음)
	//									0 : 방 정보 얻기 실패 (아래 정보 없음 / 클라이언트가 일정시간 후 재요청 해야 함)
	//
	//		WORD	BattleServerNo		배틀서버 고유번호
	//
	//		WCHAR	IP[16]				배틀서버 접속 IP
	//		WORD	Port				배틀서버 접속 Port
	//
	//		int		RoomNo				배틀서버 내 게임방 번호
	//		char	ConnectToken[32]	배틀서버 접속 토큰 (배틀서버 발행)
	//		char	EnterToken[32]		배틀서버 장 입장 토큰 (배틀서버 발행)
	//
	//		WCHAR	ChatServerIP[16]
	//		WORD	ChatServerPort
	//	}
	//
	//	배틀서버 관련 정보는 배틀서버가 마스터 서버에게 전달한 정보이며
	//	매치메이킹 서버는 마스터 서버에게서 이를 받아 클라이언트 에게 전달 한다.
	//
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_RES_GAME_ROOM,


	//------------------------------------------------------------
	// 방 입장 성공 알림
	//
	//	{
	//		WORD	Type
	//
	//		WORD	BattleServerNo
	//		int		RoomNo
	//	}
	//
	//	클라이언트는 en_PACKET_CS_MATCH_RES_GAME_ROOM 방 정보를 받으면 배틀서버에 접속을 시도한다.
	//
	//	클라이언트가 배틀서버로 부터 방 입장 성공 안내를 받기 전 까지는
	//	매치메이킹 서버와 배틀서버 2개의 서버에 모두 접속을 유지하고 있음
	//
	//	배틀서버 방 입장이 성공되면, 매치메이킹 서버에게 이 패킷을 보내서 방 입장 성공을 알려줌.
	//
	//	매치메이킹 서버는 본 패킷을 받으면 마스터 서버에게 전달 해주며, 실제 해당 방의 접속자 인원을 변경 한다.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_REQ_GAME_ROOM_ENTER,

	//------------------------------------------------------------
	// 방 입장 성공 확인
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	매치메이킹 서버는 위의 방 입장 성공 패킷을 받으면 마스터 서버에게 이를 전달 한 뒤에
	//	마스터 서버로부터 회신이 오면 클라이언트에게 결과를 보내준다.
	//
	//	이 패킷을 받으면 클라이언트는 매치메이킹 서버와의 연결을 끊게 된다.
	//	굳이 RES 확인 패킷이 있는 이유는, 클라이언트가 일방적으로 보내고 끊어 버리면 
	//	매치메이킹 서버에게 100% 전달 되었다는 확신이 어려울 수 있으므로 REQ 와 RES 를 두어서 진행.
	//------------------------------------------------------------
	en_PACKET_CS_MATCH_RES_GAME_ROOM_ENTER,


	






	////////////////////////////////////////////////////////
	//
	//   Server & Server Protocol 
	//
	////////////////////////////////////////////////////////
	en_PACKET_SS_LAN					= 10000,
	//------------------------------------------------------
	// Matchmaking Server <-> Master Server <-> Battle Server <-> Chatting Server
	//------------------------------------------------------






	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Matchmaking Server <-> Master Server
	//------------------------------------------------------
	en_PACKET_MAT_MAS					= 10000,

	//------------------------------------------------------------
	//	매치메이킹 서버가 마스터 서버에게 서버 켜짐 알림 (로그인)
	//
	//	{
	//		WORD	Type
	//
	//		int		ServerNo			// 매칭서버 번호
	//		char	MasterToken[32]		// 마스터 서버 연결 인증 토큰
	//									// 이는 사전에 서로 합의된 토큰을 정해서 가지고 있어야 함
	//	}
	//
	//	딱히 필요는 없으나 혹시모를 안전을 위해서 추가 함.
	//
	//	Lan 통신의 경우 안전한 통신만 하는것을 기본으로 가지만, 우리 프로그램 외에 다른 프로그램이
	//	실수,임의로 연결하게 될 수 있으므로 연결 인증 과정을 추가 한다.
	//
	//	Master 서버에는 고정된 토큰을 가지고 있으며 (Config 로 지정) 
	//	Matchmaking 서버도 사전에 같은 토큰을 가지고 있어야 함 (Config 로 지정)
	//
	//	보안을 위해서 Master 서버는 인증을 통하지 않은 Matchmaking 서버들의 컨텐츠를 차단 한다.
	//	Master 서버는 토큰이 다르다면 로그 남기고 그냥 끊어버림. 별도의 안내 없음.
	//
	//
	//	추가로 Matchmaking Server No 를 관리하여 중복 ServerNo 가 들어오는 경우는
	//	차단 & 로그 작업이 들어가도 좋음
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_SERVER_ON,

	//------------------------------------------------------------
	//	매치메이킹 서버의 켜임 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		int		ServerNo
	//	}
	//
	//	이제부터 Matchmaking 서버와 Master 서버 와의 통신이 가능 해졌다.
	//
	//	토큰이 달라서 로그인이 안되는 상태라면 응답 없이 마스터가 끊어버림.
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_RES_SERVER_ON,



	//------------------------------------------------------------
	//	매치메이킹 서버가 마스터 서버에게 게임방 정보를 요청
	//
	//	{
	//		WORD	Type
	//
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//	}
	//
	//	매치메이킹 서버는 클라이언트에게 게임방 정보 요청을 받으면, 이 패킷을 마스터 서버에게 보냄
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_GAME_ROOM,

	//------------------------------------------------------------
	//	마스터 서버가 응답하는 게임방 정보
	//
	//	{
	//		WORD	Type
	//
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//
	//		BYTE	Status				1 : 방 정보 얻기 성공 (아래 정보 있음)
	//									0 : 방 정보 얻기 실패 (아래 정보 없음)
	//
	//		WORD	BattleServerNo		배틀서버 고유번호
	//		WCHAR	IP[16]				배틀서버 접속 IP
	//		WORD	Port				배틀서버 접속 Port
	//		int		RoomNo				배틀서버 내 게임방 번호
	//		char	ConnectToken[32]	배틀서버 접속 토큰 (배틀서버 발행)
	//		char	EnterToken[32]		배틀서버 장 입장 토큰 (배틀서버 발행)
	//
	//		WCHAR	ChatServerIP[16]
	//		WORD	ChatServerPort
	//
	//	}
	//
	//
	//	마스터 서버는 입장 가능한 게임방이 있는경우 즉각 결과를 알려주지만
	//	지금 대기 방이 없다면, 적절한 배틀서버 에게 방생성을 요청하게 됨
	//	이때는 '방 정보 얻기 실패' 패킷을 돌려준다. 매치메이킹 서버는 이 정보를 그대로 클라이언트 에게 전달하며
	//	방 얻기 실패시 클라이언트는 일정시간 후 재 시도를 하게 될 것이다.
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_RES_GAME_ROOM,
	


	//------------------------------------------------------------
	//	유저의 방 입장 성공 안내
	//
	//	{
	//		WORD	Type
	//
	//		WORD	BattleServerNo
	//		int		RoomNo
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//	}
	//
	//	Master 서버는 해당 클라이언트 키를 탐색하여 어떤 Client 가 어떤 방에 입장을 성공 하였는지 인원을 갱신 한다.
	//
	//	(Battle 서버와 동기화 없음 / 클라이언트의 입장 확인을 하므로 )
	//	(Battle 서버가 들어왔던 유저가 나가는 경우에만 Master 서버로 인원 동기화를 함 )
	//
	//	BattleServerNo 와 RoomNo 가 있는 이유는 확인차 있는 부분.
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_ROOM_ENTER_SUCCESS,


	//------------------------------------------------------------
	//	유저의 방 입장 실패 안내
	//
	//	{
	//		WORD	Type
	//
	//		UINT64	ClientKey			클라이언트 고유 키 (매치메이킹 서버가 생성한 클라이언트 유니크 키)
	//	}
	//
	//	Master 서버는 해당 클라이언트 키를 탐색하여
	//	해당 클라이언트에게 배정 됐던 방의 참여인원을 되돌린다.
	//
	//  
	//------------------------------------------------------------
	en_PACKET_MAT_MAS_REQ_ROOM_ENTER_FAIL,










	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Battle Server <-> Master Server
	//------------------------------------------------------
	en_PACKET_BAT_MAS						= 10100,

	//
	// 마스터가 서버 / 배틀이 클라이언트 입장이므로 
	//
	// 배틀 -> 마스터 Request
	// 마스터 -> 배틀 Response 
	// 
	// 개념으로 본다.
	//

	//------------------------------------------------------------
	//	배틀서버가 마스터 서버에게 서버 켜짐 알림
	//
	//	{
	//		WORD	Type
	//
	//		WCHAR	ServerIP[16]
	//		WORD	Port
	//		char	ConnectToken[32]	배틀서버 접속 토큰 (배틀서버 발행)
	//		char	MasterToken[32]		마스터 서버 접속 토큰 (사전에 지정된 값)
	//
	//		WCHAR	ChatServerIP[16]
	//		WORD	ChatServerPort
	//	}
	//
	//	배틀서버의 접속정보를 마스터 서버에게 등록하는 과정.
	//	배틀서버가 켜지면 마스터 서버에 Connect 후, 마스터 서버에게 이 패킷을 보낸다.
	//
	//	배틀서버의 고유 번호는 마스터 서버가 부여한다.
	//	배틀 서버마다 고유번호를 각자 관리하면 중복 및 추가시 번거로울 수 있으므로...
	//
	//	ConnectToken 은 최초 서버가 발행 후 주기적으로 갱신될 것이다.
	//
	//
	//	MasterToken 은 Master 서버가 가지고 있는 고정된 연결 토큰으로 각 배틀서버 설정파일에 들고 있어야 한다.
	//	MasterToken 이 다른 경우는 Battle 서버의 연결을 끊고 로그를 남긴다.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_SERVER_ON,

	//------------------------------------------------------------
	//	배틀서버가 마스터 서버에게 서버 켜짐 응답
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo			// 마스터 서버가 부여한 서버 번호
	//	}
	//
	//	배틀서버 On 에 대한 응답.
	//
	//	큰 의미는 없으며 내 배틀서버가 정상 등록 되었는지 확인하기 위함.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_SERVER_ON,


	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 알림.
	//
	//	{
	//		WORD	Type
	//
	//		char	ConnectToken[32]		// 배틀서버가 만든 연결 토큰
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	일정 시간마다 배틀서버는 연결토큰을 재발행 하여 마스터 서버에게 전달 한다.
	//	재발행 시간 주기는 배틀서버가 결정한다.
	//
	//	배틀서버는 토큰 발행 후  이전토큰 / 새토큰  2개를 보관해야 하며  
	//	이전 토큰으로 접속을 시도하는 사용자도 완전허용 또는 일정시간 허용을 해주어야 한다.
	//
	//	ReqSequence - TCP 의 시퀀스 번호같이 패킷의 순서 및 구분을 위한 카운팅 값
	//
	//
	//	배틀 <-> 마스터 사이에는 비슷하고 구분이 어려운 패킷들이 요청/응답을 반복적으로 하게 됨
	//	이 과정에서 요청과 응답을 혼동하여 잘못된 처리가 될 우려가 있으므로, 
	//	요청자가 시퀀스 번호를 +1 씩 부여하여 요청패킷을 보내면, 응답자는 이 시퀀스 번호를 사용하여 응답 한다.
	//
	//	만약을 위해서 넣은 기능이므로 불필요 하다면 사용하지 않아도 됨.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_CONNECT_TOKEN,

	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	마스터가 잘 수신 하였는지 확인용.  
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_CONNECT_TOKEN,



	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 알림
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo
	//		int		RoomNo
	//		int		MaxUser
	//		char	EnterToken[32]
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	배틀서버는 자신이 보유한 대기방이 없을시 각자 알아서 1개 이상의 방을 생성하여 마스터 서버에게 전달 한다
	//	만약 방을 더 이상 만들 수 없는 상태라면 배틀 서버가 알아서 방생성을 중지한다. 
	//	그 이후 여유가 있을때 각자가 생성하여 마스터 서버에게 전달 한다.
	//
	//	마스터 서버가 하나하나 방 생성을 요청하지 않고,  배틀서버가 1개 이상의 대기방을 만들어서 알려주는 방식.
	//
	//	마스터 서버는 각 배틀서버의 IP/PORT 를 알고 있으므로 방에 관련 정보만 전달 한다
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_CREATED_ROOM,
	 
	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 수신 응답
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	큰 의미는 없으나 만약을 위해서 REQ / RES 짝을 맞춰 주도록 한다
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_CREATED_ROOM,


	//------------------------------------------------------------
	//	방 닫힘 알림
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	대기방이 플레이를 위해, 또는 기타 사유로 인해서 방이 닫혀짐을 마스터에게 알림
	//	마스터 서버는 해당 방의 정보를 삭제하고 사용자를 배정하지 않는다.
	//
	//	대기방 -> 플레이		본 패킷 송신
	//	플레이 -> 종료		이미 플레이시 닫혔으므로 송신 하지 않음.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_CLOSED_ROOM,

	//------------------------------------------------------------
	//	방 닫힘 수신확인
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	수신 확인용
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_CLOSED_ROOM,
	

	//------------------------------------------------------------
	//	방에서 유저가 나갔음, 1명 나갈때 마다 전송.
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	사용자가 들어가는 부분은 마스터 서버가 알아서 카운팅 하지만, 
	//	배틀서버에 들어갔다가 나간 유저는 마스터 서버가 파악 불가능.
	//
	//	그러므로 유저가 나갈 경우에만 배틀서버 -> 마스터서버 로 전달 한다.
	//
	//	현재 인원의 수치를 전달 하는것이 아닌 -1 값을 보내는 의미이므로 마스터서버는 
	//	해당 방 배정가능 인원을 +1 시켜주면 됨.
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_REQ_LEFT_USER,
	
	//------------------------------------------------------------
	//	방에서 유저가 나갔 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_BAT_MAS_RES_LEFT_USER,





	////////////////////////////////////////////////////////
	//------------------------------------------------------
	// Chat Server <-> Battle Server
	//------------------------------------------------------
	en_PACKET_CHAT_BAT						= 10500,

	//
	// 배틀서버가 LanServer / 채팅서버가 LanClient
	//
	// 채팅 -> 배틀 Request
	// 배틀 -> 채팅 Response 
	// 

	//------------------------------------------------------------
	//	채팅서버가 배틀서버에게 서버 켜짐 알림
	//
	//	{
	//		WORD	Type
	//
	//		WCHAR	ChatServerIP[16]	사용자가 접속하는 채팅서버 IP
	//		WORD	ChatServerPort		사용자가 접속하는 채팅서버 Port
	//	}
	//
	//	채팅서버가 켜지면 배틀서버에 LanClient -> LanServer 로 접속하여 본 패킷을 보낸다
	//
	//	배틀서버는 채팅서버의 정보를 전혀 가지고 있지 않으며, 
	//	채팅서버가 배틀서버에게 자신의 사용자 접속 IP/Port 를 알려주어 등록한다.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_SERVER_ON,

	//------------------------------------------------------------
	//	채팅서버가 배틀서버에게 서버 켜짐 알림 확인
	//
	//	{
	//		WORD	Type
	//	}
	//
	//	채팅서버 On 에 대한 응답.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_SERVER_ON,



	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 채팅서버에게 알림.
	//
	//	{
	//		WORD	Type
	//
	//		char	ConnectToken[32]		// 배틀서버가 만든 연결 토큰
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	마스터 서버에게 주는 토큰 재발행과 같음.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_CONNECT_TOKEN,

	//------------------------------------------------------------
	//	배틀서버의 연결토큰 재발행 수신 확인
	//
	//	{
	//		WORD	Type
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	채팅이 배틀에게 주는 응답 확인용  
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_CONNECT_TOKEN,



	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 채팅서버에게 알림
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo
	//		int		RoomNo
	//		int		MaxUser
	//		char	EnterToken[32]
	//
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	배틀서버는 방 생성시 마스터 서버와 채팅서버 에게도 이를 안내한다.
	//	채팅서버는 해당 채팅방을 생성시킨다.
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_CREATED_ROOM,
	 
	//------------------------------------------------------------
	//	배틀 서버의 신규 대기 방 생성 수신 응답
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	큰 의미는 없으나 만약을 위해서 REQ / RES 짝을 맞춰 주도록 한다
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_CREATED_ROOM,


	//------------------------------------------------------------
	//	배틀 서버의 방 삭제를 채팅서버에게 알림  (배틀 -> 채팅)
	//
	//	{
	//		WORD	Type
	//
	//		int		BattleServerNo
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	배틀서버가 방을 삭제할 때 채팅서버에게 보낸다.
	//	(Ready / Play 상태의 방 닫힘이 아니며 진짜 방 파괴)
	//
	//  채팅서버의 해당 방에 유저가 있는 경우는 끊는다.
	//
	//	필요 없을줄 알았으나... 필요성이 생겨서 추가 함. ;;;
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_REQ_DESTROY_ROOM,
	 
	//------------------------------------------------------------
	//	방 삭제 처리 확인						(채팅 -> 배틀)
	//
	//	{
	//		WORD	Type
	//
	//		int		RoomNo
	//		UINT	ReqSequence				// 메시지 시퀀스 번호 (REQ / RES 짝맞춤 용도)
	//	}
	//
	//	큰 의미는 없으나 만약을 위해서 REQ / RES 짝을 맞춰 주도록 한다
	//------------------------------------------------------------
	en_PACKET_CHAT_BAT_RES_DESTROY_ROOM,












	//------------------------------------------------------
	// Monitor Server Protocol
	//------------------------------------------------------


	////////////////////////////////////////////////////////
	//
	//   MonitorServer & MoniterTool Protocol / 응답을 받지 않음.
	//
	////////////////////////////////////////////////////////

	//------------------------------------------------------
	// Monitor Server  Protocol
	//------------------------------------------------------
	en_PACKET_SS_MONITOR					= 20000,
	//------------------------------------------------------
	// Server -> Monitor Protocol
	//------------------------------------------------------
	//------------------------------------------------------------
	// LoginServer, GameServer , ChatServer , Agent 가 모니터링 서버에 로그인 함
	//
	// 
	//	{
	//		WORD	Type
	//
	//		BYTE	ServerType				// Login / Game / Chat / Agent	하단 Define 됨.
	//		WCHAR	ServerName[32]			// Game,Chat,Agent 서버는 이름으로 서버 ID 를 맵핑함.
	//										// ServerLink.cnf 파일의 이름 사용
	//
	//										// Login 서버는 'LOGIN' 
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_SS_MONITOR_LOGIN,

	//------------------------------------------------------------
	// 서버가 모니터링서버로 데이터 전송
	// 각 서버는 자신이 모니터링중인 수치를 1초마다 모니터링 서버로 전송.
	//
	// 서버의 다운 및 기타 이유로 모니터링 데이터가 전달되지 못할떄를 대비하여 TimeStamp 를 전달한다.
	// 이는 모니터링 클라이언트에서 계산,비교 사용한다.
	// 
	//	{
	//		WORD	Type
	//
	//		BYTE	DataType				// 모니터링 데이터 Type 하단 Define 됨.
	//		int		DataValue				// 해당 데이터 수치.
	//		int		TimeStamp				// 해당 데이터를 얻은 시간 TIMESTAMP  (time() 함수)
	//										// 본래 time 함수는 time_t 타입변수이나 64bit 로 낭비스러우니
	//										// int 로 캐스팅하여 전송. 그래서 2038년 까지만 사용가능
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_SS_MONITOR_DATA_UPDATE,


	en_PACKET_CS_MONITOR					= 25000,
	//------------------------------------------------------
	// Monitor -> Monitor Tool Protocol  (Client <-> Server 프로토콜)
	//------------------------------------------------------
	//------------------------------------------------------------
	// 모니터링 클라이언트(툴) 이 모니터링 서버로 로그인 요청
	//
	//	{
	//		WORD	Type
	//
	//		WCHAR	ServerName[32]			// 모니터링 대상 서버 이름 
	//										// ServerLink.cnf 파일의 이름 사용
	//
	//										// 통합모니터링은 'COMMON' 사용
	//
	//		char	LoginSessionKey[32]		// 로그인 인증 키. (이는 모니터링 서버에 고정값으로 보유)
	//										// 각 모니터링 툴은 같은 키를 가지고 들어와야 함
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_REQ_LOGIN,

	//------------------------------------------------------------
	// 모니터링 클라이언트(툴) 모니터링 서버로 로그인 응답
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	ServerNo				// 지정 서버 No
	//		BYTE	Status					// 로그인 결과 0 / 1 / 2 ... 하단 Define
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_RES_LOGIN,

	//------------------------------------------------------------
	// 모니터링 서버가 모니터링 클라이언트(툴) 에게 모니터링 데이터 전송
	// 모니터링 툴이 모니터링 서버로 로그인 시 서버를 지정 하였다면 해당 서버의 모니터링 데이터만 전송.
	//
	// 모니터링 툴이 모니터링 서버로 'COMMON' 통합 모니터링으로 로그인 하였다면 
	// 모든 서버에 대한 모니터링 데이터를 보내준다.
	//
	// 이 모니터링 데이터는 각 서버가 모니터링 서버에게 보내준 데이터를 그대로 릴레이 전달하는 데이터임.
	//
	// COMMON 통합 모니터링 클라의경우 모니터링 데이터가 생각보다 많음.
	// 이 데이터를 절약하기 위해서는 초단위로 모든 데이터를 묶어서 30~40개의 모니터링 데이터를 하나의 패킷으로 만드는게
	// 좋으나  여러가지 생각할 문제가 많으므로 그냥 각각의 모니터링 데이터를 개별적으로 전송처리 한다.
	//
	//	{
	//		WORD	Type
	//		
	//		BYTE	ServerNo				// 서버 No
	//		BYTE	DataType				// 모니터링 데이터 Type 하단 Define 됨.
	//		int		DataValue				// 해당 데이터 수치.
	//		int		TimeStamp				// 해당 데이터를 얻은 시간 TIMESTAMP  (time() 함수)
	//										// 본래 time 함수는 time_t 타입변수이나 64bit 로 낭비스러우니
	//										// int 로 캐스팅하여 전송. 그래서 2038년 까지만 사용가능
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_DATA_UPDATE,


	//------------------------------------------------------------
	// 모니터링 클라이언트(툴) 가 모니터링 서버에게 서버 컨트롤
	//
	// 이는 모니터링 서버에서 각 클라(모니터링 툴) 에게 지정된 서버의 에이전트에게 재전달 됨.
	// * 채팅서버는 Shutdown 기능이 없음.  
	//
	//	{
	//		WORD	Type
	//
	//		BYTE	ServerType				// 컨트롤 대상 서버  하단 Define 사용
	//		BYTE	Control					// 컨트롤 명령, Run / Terminate / Shutdown   하단 Define 사용
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_CS_MONITOR_TOOL_SERVER_CONTROL,




	////////////////////////////////////////////////////////
	//
	//   GameServer & Agent Protocol / 응답을 받지 않음.
	//
	////////////////////////////////////////////////////////
	en_PACKET_SS_AGENT							= 30000,
	//------------------------------------------------------
	// Agent Protocol
	//------------------------------------------------------
	//------------------------------------------------------------
	// Agent 가 GameServer 에게 서버종료 명령을 날림
	// 게임서버는 Agent 에게 이 메시지를 받으면 즉시 서버를 중단한다.
	//
	//	{
	//		WORD	Type
	//
	//	}
	//
	//------------------------------------------------------------
	en_PACKET_SS_AGENT_GAMESERVER_SHUTDOWN,

};



enum en_PACKET_CS_LOGIN_RES_LOGIN 
{
	dfLOGIN_STATUS_NONE				= -1,		// 미인증상태
	dfLOGIN_STATUS_FAIL				= 0,		// 세션오류
	dfLOGIN_STATUS_OK				= 1,		// 성공
	dfLOGIN_STATUS_GAME				= 2,		// 게임중
	dfLOGIN_STATUS_ACCOUNT_MISS		= 3,		// account 테이블에 AccountNo 없음
	dfLOGIN_STATUS_SESSION_MISS		= 4,		// Session 테이블에 AccountNo 없음
	dfLOGIN_STATUS_STATUS_MISS		= 5,		// Status 테이블에 AccountNo 없음
	dfLOGIN_STATUS_NOSERVER			= 6,		// 서비스중인 서버가 없음.
};


enum en_PACKET_CS_GAME_RES_LOGIN 
{
	dfGAME_LOGIN_FAIL				= 0,		// 세션키 오류 또는 Account 데이블상의 오류
	dfGAME_LOGIN_OK					= 1,		// 성공
	dfGAME_LOGIN_NOCHARACTER		= 2,		// 성공 / 캐릭터 없음 > 캐릭터 선택화면으로 전환. 
	dfGAME_LOGIN_VERSION_MISS		= 3,		// 서버,클라 버전 다름
};



enum en_PACKET_SS_LOGINSERVER_LOGIN
{
	dfSERVER_TYPE_GAME		= 1,
	dfSERVER_TYPE_CHAT		= 2,
	dfSERVER_TYPE_MONITOR	= 3,
};

enum en_PACKET_SS_HEARTBEAT
{
	dfTHREAD_TYPE_WORKER	= 1,
	dfTHREAD_TYPE_DB		= 2,
	dfTHREAD_TYPE_GAME		= 3,
};

// en_PACKET_SS_MONITOR_LOGIN
enum en_PACKET_CS_MONITOR_TOOL_SERVER_CONTROL
{
	dfMONITOR_SERVER_TYPE_LOGIN		= 1,
	dfMONITOR_SERVER_TYPE_GAME		= 2,
	dfMONITOR_SERVER_TYPE_CHAT		= 3,
	dfMONITOR_SERVER_TYPE_AGENT		= 4,

	dfMONITOR_SERVER_CONTROL_SHUTDOWN			= 1,		// 서버 정상종료 (게임서버 전용)
	dfMONITOR_SERVER_CONTROL_TERMINATE			= 2,		// 서버 프로세스 강제종료
	dfMONITOR_SERVER_CONTROL_RUN				= 3,		// 서버 프로세스 생성 & 실행
};


enum en_PACKET_SS_MONITOR_DATA_UPDATE
{
	dfMONITOR_DATA_TYPE_LOGIN_SESSION				= 1,		// 로그인서버 세션 수 (컨넥션 수)
	dfMONITOR_DATA_TYPE_LOGIN_AUTH_TPS				= 2,		// 로그인서버 인증 처리 초당 횟수
	dfMONITOR_DATA_TYPE_LOGIN_PACKET_POOL			= 3,		// 로그인서버 패킷풀 사용량
	dfMONITOR_DATA_TYPE_LOGIN_SERVER_ON				= 4,		// 켜진서버 서버 개수
	dfMONITOR_DATA_TYPE_LOGIN_LIVE_SERVER			= 5,		// 현재 라이브 지정 서버 번호

	dfMONITOR_DATA_TYPE_GAME_SESSION				= 6,		// 게임서버 세션 수 (컨넥션 수)
	dfMONITOR_DATA_TYPE_GAME_AUTH_PLAYER			= 7,		// 게임서버 AUTH MODE 플레이어 수
	dfMONITOR_DATA_TYPE_GAME_GAME_PLAYER			= 8,		// 게임서버 GAME MODE 플레이어 수
	dfMONITOR_DATA_TYPE_GAME_ACCEPT_TPS				= 9,		// 게임서버 Accept 처리 초당 횟수
	dfMONITOR_DATA_TYPE_GAME_PACKET_PROC_TPS		= 10,		// 게임서버 패킷처리 초당 횟수
	dfMONITOR_DATA_TYPE_GAME_PACKET_SEND_TPS		= 11,		// 게임서버 패킷 보내기 초당 완료 횟수
	dfMONITOR_DATA_TYPE_GAME_DB_WRITE_TPS			= 12,		// 게임서버 DB 저장 메시지 초당 처리 횟수
	dfMONITOR_DATA_TYPE_GAME_DB_WRITE_MSG			= 13,		// 게임서버 DB 저장 메시지 버퍼 개수 (남은 수)
	dfMONITOR_DATA_TYPE_GAME_AUTH_THREAD_FPS		= 14,		// 게임서버 AUTH 스레드 초당 프레임 수 (루프 수)
	dfMONITOR_DATA_TYPE_GAME_GAME_THREAD_FPS		= 15,		// 게임서버 GAME 스레드 초당 프레임 수 (루프 수)
	dfMONITOR_DATA_TYPE_GAME_PACKET_POOL			= 16,		// 게임서버 패킷풀 사용량
	
	dfMONITOR_DATA_TYPE_CHAT_SESSION				= 17,		// 채팅서버 세션 수 (컨넥션 수)
	dfMONITOR_DATA_TYPE_CHAT_PLAYER					= 18,		// 채팅서버 인증성공 사용자 수 (실제 접속자)
	dfMONITOR_DATA_TYPE_CHAT_UPDATE_TPS				= 19,		// 채팅서버 UPDATE 스레드 초당 초리 횟수
	dfMONITOR_DATA_TYPE_CHAT_PACKET_POOL			= 20,		// 채팅서버 패킷풀 사용량
	dfMONITOR_DATA_TYPE_CHAT_UPDATEMSG_POOL			= 21,		// 채팅서버 UPDATE MSG 풀 사용량
	
	dfMONITOR_DATA_TYPE_AGENT_GAME_SERVER_RUN		= 22,		// 에이전트 GameServer 실행 여부 ON / OFF
	dfMONITOR_DATA_TYPE_AGENT_CHAT_SERVER_RUN		= 23,		// 에이전트 ChatServer 실행 여부 ON / OFF
	dfMONITOR_DATA_TYPE_AGENT_GAME_SERVER_CPU		= 24,		// 에이전트 GameServer CPU 사용률
	dfMONITOR_DATA_TYPE_AGENT_CHAT_SERVER_CPU		= 25,		// 에이전트 ChatServer CPU 사용률
	dfMONITOR_DATA_TYPE_AGENT_GAME_SERVER_MEM		= 26,		// 에이전트 GameServer 메모리 사용 MByte
	dfMONITOR_DATA_TYPE_AGENT_CHAT_SERVER_MEM		= 27,		// 에이전트 ChatServer 메모리 사용 MByte
	dfMONITOR_DATA_TYPE_AGENT_CPU_TOTAL				= 28,		// 에이전트 서버컴퓨터 CPU 전체 사용률
	dfMONITOR_DATA_TYPE_AGENT_NONPAGED_MEMORY		= 29,		// 에이전트 서버컴퓨터 논페이지 메모리 MByte	// 최근 수정
	dfMONITOR_DATA_TYPE_AGENT_NETWORK_RECV			= 30,		// 에이전트 서버컴퓨터 네트워크 수신량 KByte	// 최근 수정
	dfMONITOR_DATA_TYPE_AGENT_NETWORK_SEND			= 31,		// 에이전트 서버컴퓨터 네트워크 송신량 KByte	// 최근 수정
	dfMONITOR_DATA_TYPE_AGENT_						= 32,		// 에이전트 서버컴퓨터 
	dfMONITOR_DATA_TYPE_AGENT_AVAILABLE_MEMORY		= 33,		// 에이전트 서버컴퓨터 사용가능 메모리
};


enum en_PACKET_CS_MONITOR_TOOL_RES_LOGIN
{
	dfMONITOR_TOOL_LOGIN_OK						= 1,		// 로그인 성공
	dfMONITOR_TOOL_LOGIN_ERR_NOSERVER			= 2,		// 서버이름 오류 (매칭미스)
	dfMONITOR_TOOL_LOGIN_ERR_SESSIONKEY			= 3,		// 로그인 세션키 오류
};


//#endif